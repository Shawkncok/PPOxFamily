<!DOCTYPE html>
<html><head><meta charset="utf-8"></meta><title>Annonated Algorithm Visualization</title><link rel="stylesheet" href="pylit.css?v=1"></link><link rel="stylesheet" href="solarized.css"></link><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css" integrity="sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/" crossorigin="anonymous"></link><script src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js" integrity="sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);" defer="True"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.61.0/lib/codemirror.min.css"></link><script src="https://cdn.jsdelivr.net/npm/codemirror@5.61.0/lib/codemirror.min.js"></script><script src="https://cdn.jsdelivr.net/npm/codemirror@5.61.0/mode/python/python.min.js"></script></head><body><div class="section" id="section-0"><div class="docs doc-strings"><p><p><a href="index.html"><b>HOME<br></b></a></p></p><a href="https://github.com/opendilab/PPOxFamily" target="_blank"><img alt="GitHub" style="max-width:100%;" src="https://img.shields.io/github/stars/opendilab/PPOxFamily?style=social"></img></a>  <a href="https://space.bilibili.com/1112854351?spm_id_from=333.337.0.0" target="_blank"><img alt="bilibili" style="max-width:100%;" src="https://img.shields.io/badge/bilibili-video%20course-blue"></img></a>  <a href="https://twitter.com/OpenDILab" rel="nofollow" target="_blank"><img alt="twitter" style="max-width:100%;" src="https://img.shields.io/twitter/follow/opendilab?style=social"></img></a><br><a href="https://github.com/opendilab/PPOxFamily/tree/main/chapter1_overview/ppo_zh.py" target="_blank">View code on GitHub</a><br><br>``Proximal Policy Optimization (PPO)</span> 算法的 PyTorch 版实现。<br><br>PPO 是强化学习中最常用的算法之一，它结合了 Actor-Critic 方法和信赖域策略优化方法（Trust Region Policy Optimization）。<br>对于策略部分，PPO 通过结合裁剪过的优化目标和悲观界（pessimistic bound）来更新策略。对于价值函数部分，PPO 通常使用经典的时间差分方法（例如GAE）。<br>最终目标函数形式化定义为:<br>$$\min(\frac{\pi_{\theta}(a_{t}|s_{t})}{\pi_{\theta_k}(a_{t}|s_{t})}A^{\theta_k}(s_{t},a_{t}),\text{clip}(\frac{\pi_{\theta}(a_{t}|s_{t})}{\pi_{\theta_k}(a_{t}|s_{t})}, 1-\epsilon,1+\epsilon)A^{\theta_k}(s_{t},a_{t}))$$<br><br>本文档主要包括:<br>- PPO error 的实现。<br>- 主函数（测试函数）</div></div><div class="section" id="section-1"><div class="docs doc-strings"><p>    <b>概述</b><br>        <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">Proximal Policy Optimization (PPO) <a href="https://arxiv.org/pdf/1707.06347.pdf">Related Link</a></span> 算法的 PyTorch 版实现。包含 entropy bounus, value_clip 和 dual_clip 功能。</p></div><div class="code"><pre><code id="code_1" name="py_code">from typing import Optional, Tuple
from collections import namedtuple
import torch
import numpy as np


ppo_policy_data = namedtuple('ppo_policy_data', ['logit_new', 'logit_old', 'action', 'adv', 'weight'])
ppo_policy_loss = namedtuple('ppo_policy_loss', ['policy_loss', 'entropy_loss'])
ppo_info = namedtuple('ppo_info', ['approx_kl', 'clipfrac'])


def ppo_policy_error(data: namedtuple,
                     clip_ratio: float = 0.2,
                     dual_clip: Optional[float] = None) -> Tuple[namedtuple, namedtuple]:</code></pre></div></div><div class="section" id="section-3"><div class="docs doc-strings"><p>    对数据 data 进行解包: $$<\pi_{new}(a|s), \pi_{old}(a|s), a, A^{\pi_{old}}(s, a), w>$$</p></div><div class="code"><pre><code id="code_3" name="py_code">    logit_new, logit_old, action, adv, weight = data</code></pre></div></div><div class="section" id="section-4"><div class="docs doc-strings"><p>    准备默认的权重（weight）。</p></div><div class="code"><pre><code id="code_4" name="py_code">    if weight is None:
        weight = torch.ones_like(adv)</code></pre></div></div><div class="section" id="section-5"><div class="docs doc-strings"><p>    根据 logit 构建策略分布，然后得到对应动作的概率的对数值。</p></div><div class="code"><pre><code id="code_5" name="py_code">    dist_new = torch.distributions.categorical.Categorical(logits=logit_new)
    dist_old = torch.distributions.categorical.Categorical(logits=logit_old)
    logp_new = dist_new.log_prob(action)
    logp_old = dist_old.log_prob(action)</code></pre></div></div><div class="section" id="section-6"><div class="docs doc-strings"><p>    熵奖赏（bonus）损失函数: $$\frac 1 N \sum_{n=1}^{N} \sum_{a^n}\pi_{new}(a^n|s^n) log(\pi_{new}(a^n|s^n))$$<br>    注意：最终的损失函数是 <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">policy_loss - entropy_weight * entropy_loss</span> .</p></div><div class="code"><pre><code id="code_6" name="py_code">    dist_new_entropy = dist_new.entropy()
    entropy_loss = (dist_new_entropy * weight).mean()</code></pre></div></div><div class="section" id="section-7"><div class="docs doc-strings"><p>    重要性采样的权重: $$r(\theta) = \frac{\pi_{new}(a|s)}{\pi_{old}(a|s)}$$</p></div><div class="code"><pre><code id="code_7" name="py_code">    ratio = torch.exp(logp_new - logp_old)</code></pre></div></div><div class="section" id="section-8"><div class="docs doc-strings"><p>    原始的代理目标: $$r(\theta) A^{\pi_{old}}(s, a)$$</p></div><div class="code"><pre><code id="code_8" name="py_code">    surr1 = ratio * adv</code></pre></div></div><div class="section" id="section-9"><div class="docs doc-strings"><p>    <b>裁剪后的代理目标:</b> $$clip(r(\theta), 1-\epsilon, 1+\epsilon) A^{\pi_{old}}(s, a)$$</p></div><div class="code"><pre><code id="code_9" name="py_code">    surr2 = ratio.clamp(1 - clip_ratio, 1 + clip_ratio) * adv</code></pre></div></div><div class="section" id="section-10"><div class="docs doc-strings"><p>    论文 <a href="https://arxiv.org/abs/1912.09729">Related Link</a> 中提出的双重裁剪目标（Dual clip）<br>    只有当 adv < 0 时才使用 Dual clip</p></div><div class="code"><pre><code id="code_10" name="py_code">    if dual_clip is not None:
        clip1 = torch.min(surr1, surr2)
        clip2 = torch.max(clip1, dual_clip * adv)
        policy_loss = -(torch.where(adv < 0, clip2, clip1) * weight).mean()</code></pre></div></div><div class="section" id="section-11"><div class="docs doc-strings"><p>    PPO-Clipped 损失: $$min(r(\theta) A^{\pi_{old}}(s, a), clip(r(\theta), 1-\epsilon, 1+\epsilon) A^{\pi_{old}}(s, a))$$<br>    在样本的维度乘以权重，然后在 batch 的维度执行求均值操作。</p></div><div class="code"><pre><code id="code_11" name="py_code">    else:
        policy_loss = (-torch.min(surr1, surr2) * weight).mean()</code></pre></div></div><div class="section" id="section-12"><div class="docs doc-strings"><p>    添加一些可视化指标来监控优化状态，故使用关闭梯度计算的上下文。</p></div><div class="code"><pre><code id="code_12" name="py_code">    with torch.no_grad():
        approx_kl = (logp_old - logp_new).mean().item()
        clipped = ratio.gt(1 + clip_ratio) | ratio.lt(1 - clip_ratio)
        clipfrac = torch.as_tensor(clipped).float().mean().item()</code></pre></div></div><div class="section" id="section-13"><div class="docs doc-strings"><p>    返回最终的损失函数和相关统计信息。</p></div><div class="code"><pre><code id="code_13" name="py_code">    return ppo_policy_loss(policy_loss, entropy_loss), ppo_info(approx_kl, clipfrac)

</code></pre></div></div><div class="section" id="section-14"><div class="docs doc-strings"><p>    <b>概述</b><br>        PPO 算法的测试函数，包括前向和反向传播过程。</p></div><div class="code"><pre><code id="code_14" name="py_code">def test_ppo(clip_ratio, dual_clip):</code></pre></div></div><div class="section" id="section-16"><div class="docs doc-strings"><p>    设置相关参数：batch size=4, action=32</p></div><div class="code"><pre><code id="code_16" name="py_code">    B, N = 4, 32</code></pre></div></div><div class="section" id="section-17"><div class="docs doc-strings"><p>    从随机分布中生成测试数据：logit_new, logit_old, action, adv.</p></div><div class="code"><pre><code id="code_17" name="py_code">    logit_new = torch.randn(B, N).requires_grad_(True)
    logit_old = logit_new + torch.rand_like(logit_new) * 0.1
    action = torch.randint(0, N, size=(B, ))
    adv = torch.rand(B)
    data = ppo_policy_data(logit_new, logit_old, action, adv, None)</code></pre></div></div><div class="section" id="section-18"><div class="docs doc-strings"><p>    计算 PPO error。</p></div><div class="code"><pre><code id="code_18" name="py_code">    loss, info = ppo_policy_error(data, clip_ratio=clip_ratio, dual_clip=dual_clip)</code></pre></div></div><div class="section" id="section-19"><div class="docs doc-strings"><p>    测试 loss 是否是可微分的，是否能正确产生梯度</p></div><div class="code"><pre><code id="code_19" name="py_code">    assert all([np.isscalar(i) for i in info])
    assert logit_new.grad is None
    total_loss = sum(loss)
    total_loss.backward()
    assert isinstance(logit_new.grad, torch.Tensor)

</code></pre></div></div><div class="section" id="section-19"><div class="docs doc-strings"><p><i>如果读者关于本文档有任何问题和建议，可以在 GitHub 提 issue 或是直接发邮件给我们 (opendilab@pjlab.org.cn) 。</i></p></div></div></body><script type="text/javascript">
window.onload = function(){
    var codeElement = document.getElementsByName('py_code');
    var lineCount = 1;
    for (var i = 0; i < codeElement.length; i++) {
        var code = codeElement[i].innerText;
        if (code.length <= 1) {
            continue;
        }

        codeElement[i].innerHTML = "";

        var codeMirror = CodeMirror(
          codeElement[i],
          {
            value: code,
            mode: "python",
            theme: "solarized dark",
            lineNumbers: true,
            firstLineNumber: lineCount,
            readOnly: false,
            lineWrapping: true,
          }
        );
        var noNewLineCode = code.replace(/[\r\n]/g, "");
        lineCount += code.length - noNewLineCode.length + 1;
    }
};
</script></html>